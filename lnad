import streamlit as st
import pandas as pd
import requests
import json
import os
import time
from typing import Dict, List, Optional, Tuple
from datetime import datetime

# ==================== ìƒìˆ˜ ì •ì˜ ====================


APT_NUM = 116750
API_URL_TEMPLATE = 'https://m.land.naver.com/complex/getComplexArticleList?hscpNo={APT_NUM}&tradTpcd=b1&order=spc_&page={i}'
DATA_FILE = 'data.txt'
MAX_PAGES = 100
REQUEST_TIMEOUT = 10
DELAY_BETWEEN_REQUESTS = 1
HEADERS = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
}

# ==================== ì„¸ì…˜ ìƒíƒœ ì´ˆê¸°í™” ====================
if 'data' not in st.session_state:
    st.session_state.data = None
if 'df' not in st.session_state:
    st.session_state.df = None
if 'last_update' not in st.session_state:
    st.session_state.last_update = None


# ==================== ë°ì´í„° ì²˜ë¦¬ í•¨ìˆ˜ ====================

@st.cache_data(ttl=3600, show_spinner=False)
def create_dataframe(data: Dict) -> pd.DataFrame:
    """JSON ë°ì´í„°ë¥¼ pandas DataFrameìœ¼ë¡œ ë³€í™˜ (1ì‹œê°„ ìºì‹±)"""
    
    if not isinstance(data, dict) or 'result' not in data or 'list' not in data['result']:
        return pd.DataFrame()
        
    apt_list = data['result']['list']
    if not apt_list:
        return pd.DataFrame()
    
    processed_data = []
    for apt in apt_list:
        # ì „ìš©ë©´ì  ì¶”ì¶œ (ìˆ«ìí˜•ìœ¼ë¡œ ë³€í™˜)
        try:
            exclusive_area = float(apt.get('spc2', '0'))
        except (ValueError, TypeError):
            exclusive_area = 0.0

        # ë§¤ë¬¼ëª… ìƒì„±
        atcl_nm = apt.get('atclNm', 'N/A')
        bild_nm = apt.get('bildNm', 'N/A')
        prc_info = apt.get('prcInfo', 'N/A')
        trad_tp_nm = apt.get('tradTpNm', 'N/A')
        name = f"{atcl_nm} {bild_nm} - {prc_info} ({trad_tp_nm})"
        
        # ë©´ì  ì •ë³´
        area_info = f"{apt.get('spc1', 'N/A')}ã¡ / {apt.get('spc2', 'N/A')}ã¡"
        
        # ì¸µ ì •ë³´ ì²˜ë¦¬
        floor_info = apt.get('flrInfo', 'N/A')
        if floor_info != 'N/A' and '/' in str(floor_info):
            floor_info = floor_info.replace('/', 'ì¸µ ì¤‘ ') + 'ì¸µ'
        
        # íƒœê·¸ ì²˜ë¦¬
        tags = ", ".join(apt.get('tagList', []))
        
        processed_data.append({
            'ë§¤ë¬¼ë²ˆí˜¸': apt.get('atclNo', 'N/A'),
            'ë§¤ë¬¼ëª…': name,
            'ê±°ë˜ìœ í˜•': trad_tp_nm,
            'ì•„íŒŒíŠ¸ëª…': atcl_nm,
            'ë™': bild_nm,
            'ê°€ê²©': prc_info,
            'ë©´ì ': area_info,
            'ì „ìš©ë©´ì ': exclusive_area,
            'ì¸µìˆ˜': floor_info,
            'ë°©í–¥': apt.get('direction', 'N/A'),
            'íŠ¹ì§•': apt.get('atclFetrDesc', ''),
            'í™•ì¸ì¼': apt.get('cfmYmd', 'N/A'),
            'ì¤‘ê°œì‚¬': apt.get('rltrNm', 'N/A'),
            'íƒœê·¸': tags
        })
        
    return pd.DataFrame(processed_data)


def download_all_pages(url_template: str, max_pages: int = MAX_PAGES) -> Optional[Dict]:
    """APIì—ì„œ ëª¨ë“  í˜ì´ì§€ ë°ì´í„°ë¥¼ ìˆ˜ì§‘"""
    
    st.info("ğŸ”„ APIì—ì„œ ë°ì´í„°ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ëŠ” ì¤‘...")
    
    all_apt_list = []
    page = 1
    
    progress_bar = st.progress(0)
    status_text = st.empty()

    session = requests.Session()
    session.headers.update(HEADERS)

    while page <= max_pages:
        url = url_template.format(i=page)
        
        try:
            status_text.text(f"ğŸ“„ í˜ì´ì§€ {page} ì²˜ë¦¬ ì¤‘...")
            response = session.get(url, timeout=REQUEST_TIMEOUT)
            response.raise_for_status()
            json_data = response.json()
            
            current_list = json_data.get('result', {}).get('list', [])
            is_last = json_data.get('result', {}).get('isLast', False)

            if not current_list:
                status_text.text(f"âœ… í˜ì´ì§€ {page}ì— ë°ì´í„° ì—†ìŒ")
                break
                
            all_apt_list.extend(current_list)
            
            if is_last:
                status_text.text(f"âœ… ë§ˆì§€ë§‰ í˜ì´ì§€ ë„ë‹¬")
                break
            
            page += 1
            progress_bar.progress(min(page / max_pages, 1.0))
            time.sleep(DELAY_BETWEEN_REQUESTS)
            
        except requests.exceptions.RequestException as e:
            status_text.error(f"âŒ API ì˜¤ë¥˜: {e}")
            break
        except json.JSONDecodeError:
            status_text.error(f"âŒ JSON íŒŒì‹± ì˜¤ë¥˜")
            break
        except Exception as e:
            status_text.error(f"âŒ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
            break
    
    progress_bar.empty()
    status_text.empty()
    
    if not all_apt_list:
        return None
        
    final_data = {'result': {'list': all_apt_list}}
    st.success(f"âœ… {len(all_apt_list)}ê°œ ë§¤ë¬¼ ìˆ˜ì§‘ ì™„ë£Œ ({page-1}í˜ì´ì§€)")
    
    return final_data


def save_data(data: Dict, file_name: str = DATA_FILE) -> bool:
    """ë°ì´í„°ë¥¼ ë¡œì»¬ íŒŒì¼ì— ì €ì¥"""
    try:
        with open(file_name, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        return True
    except Exception as e:
        st.error(f"âŒ íŒŒì¼ ì €ì¥ ì˜¤ë¥˜: {e}")
        return False


def load_data(file_name: str = DATA_FILE) -> Optional[Dict]:
    """ë¡œì»¬ íŒŒì¼ì—ì„œ ë°ì´í„° ë¡œë“œ"""
    if not os.path.exists(file_name):
        return None

    try:
        with open(file_name, 'r', encoding='utf-8') as f:
            data = json.load(f)
        
        count = len(data.get('result', {}).get('list', []))
        mod_time = datetime.fromtimestamp(os.path.getmtime(file_name))
        
        st.success(f"ğŸ“‚ {count}ê°œ ë§¤ë¬¼ ë¡œë“œ (ì—…ë°ì´íŠ¸: {mod_time.strftime('%Y-%m-%d %H:%M')})")
        
        return data
    except Exception as e:
        st.error(f"âŒ íŒŒì¼ ë¡œë“œ ì˜¤ë¥˜: {e}")
        return None


def get_area_range(df: pd.DataFrame) -> Tuple[float, float]:
    """DataFrameì—ì„œ ë©´ì  ë²”ìœ„ ì¶”ì¶œ"""
    if df.empty or 'ì „ìš©ë©´ì ' not in df.columns:
        return 0.0, 100.0
    
    min_area = float(df['ì „ìš©ë©´ì '].min())
    max_area = float(df['ì „ìš©ë©´ì '].max())
    
    # 0ì¸ ê°’ë“¤ ì œì™¸
    valid_areas = df[df['ì „ìš©ë©´ì '] > 0]['ì „ìš©ë©´ì ']
    if not valid_areas.empty:
        min_area = float(valid_areas.min())
        max_area = float(valid_areas.max())
    
    return min_area, max_area


def apply_filters(df: pd.DataFrame, 
                  trade_type: str, 
                  dong: str, 
                  area_range: Tuple[float, float]) -> pd.DataFrame:
    """í•„í„° ì¡°ê±´ì„ ì ìš©í•˜ì—¬ ë°ì´í„°í”„ë ˆì„ í•„í„°ë§"""
    filtered = df.copy()
    
    # ê±°ë˜ ìœ í˜• í•„í„°
    if trade_type != 'ì „ì²´':
        filtered = filtered[filtered['ê±°ë˜ìœ í˜•'] == trade_type]
    
    # ë™ í•„í„°
    if dong != 'ì „ì²´':
        filtered = filtered[filtered['ë™'] == dong]
    
    # ë©´ì  í•„í„°
    min_sqm, max_sqm = area_range
    filtered = filtered[
        (filtered['ì „ìš©ë©´ì '] >= min_sqm) & 
        (filtered['ì „ìš©ë©´ì '] <= max_sqm)
    ]
    
    return filtered


def render_property_details(apt_data: pd.Series):
    """ì„ íƒëœ ë§¤ë¬¼ì˜ ìƒì„¸ ì •ë³´ í‘œì‹œ"""
    st.markdown("---")
    st.subheader(f"âœ¨ {apt_data['ì•„íŒŒíŠ¸ëª…']} {apt_data['ë™']}")

    col1, col2, col3 = st.columns(3)

    with col1:
        st.metric("ê±°ë˜ìœ í˜•", apt_data['ê±°ë˜ìœ í˜•'])
        st.metric("ê°€ê²©", apt_data['ê°€ê²©'])
        
    with col2:
        st.metric("ë©´ì ", apt_data['ë©´ì '])
        st.metric("ì¸µìˆ˜", apt_data['ì¸µìˆ˜'])
        
    with col3:
        st.metric("ë°©í–¥", apt_data['ë°©í–¥'])
        st.metric("í™•ì¸ì¼", apt_data['í™•ì¸ì¼'])
    
    st.markdown("---")
    
    if apt_data['íŠ¹ì§•']:
        st.write("**ë§¤ë¬¼ íŠ¹ì§•**")
        st.info(apt_data['íŠ¹ì§•'])
    
    if apt_data['íƒœê·¸']:
        st.info(f"{apt_data['íƒœê·¸']}")
    
    # col_a, col_b = st.columns(2)
    # with col_a:
    # st.write(f"**ì¤‘ê°œì‚¬:** {apt_data['ì¤‘ê°œì‚¬']}")
    # with col_b:
    #     st.write(f"**ë§¤ë¬¼ë²ˆí˜¸:** {apt_data['ë§¤ë¬¼ë²ˆí˜¸']}")


# ==================== ë©”ì¸ ì•± ====================

st.set_page_config(
    page_title="ì•„íŒŒíŠ¸ ë§¤ë¬¼ ì •ë³´",
    page_icon="ğŸ ",
    layout="wide"
)

st.title('ğŸ  ì•„íŒŒíŠ¸ ë§¤ë¬¼ ì •ë³´ ì¡°íšŒ')

# ==================== ì‚¬ì´ë“œë°”: ë°ì´í„° ê´€ë¦¬ ====================

with st.sidebar:
    st.header("âš™ï¸ ë°ì´í„° ê´€ë¦¬")
    
    col_btn1, col_btn2 = st.columns(2)
    
    with col_btn1:
        if st.button("ğŸ”„ ìƒˆë¡œê³ ì¹¨", use_container_width=True):
            with st.spinner("ë‹¤ìš´ë¡œë“œ ì¤‘..."):
                new_data = download_all_pages(API_URL_TEMPLATE)
                if new_data:
                    if save_data(new_data):
                        st.session_state.data = new_data
                        st.session_state.df = None  # DataFrame ì¬ìƒì„± ìœ ë„
                        st.session_state.last_update = datetime.now()
                        st.rerun()
    
    with col_btn2:
        if st.button("ğŸ—‘ï¸ ì´ˆê¸°í™”", use_container_width=True):
            if os.path.exists(DATA_FILE):
                os.remove(DATA_FILE)
            st.session_state.clear()
            st.rerun()
    
    if st.session_state.last_update:
        st.caption(f"ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: {st.session_state.last_update.strftime('%H:%M:%S')}")

# ==================== ë°ì´í„° ë¡œë“œ ====================

if st.session_state.data is None:
    data = load_data()
    
    if data is None:
        data = download_all_pages(API_URL_TEMPLATE)
        if data:
            save_data(data)
            st.session_state.last_update = datetime.now()
    
    if data is None or not data.get('result', {}).get('list'):
        st.error("âŒ ë°ì´í„° ìˆ˜ì§‘ ì‹¤íŒ¨")
        st.stop()
    
    st.session_state.data = data

# DataFrame ìƒì„±
if st.session_state.df is None:
    st.session_state.df = create_dataframe(st.session_state.data)

df = st.session_state.df

if df.empty:
    st.error("âŒ ìœ íš¨í•œ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.")
    st.stop()

# ==================== ì‚¬ì´ë“œë°”: í•„í„° ì˜µì…˜ ====================

with st.sidebar:
    st.markdown("---")
    st.header("ğŸ” í•„í„° ì˜µì…˜")
    
    # 1. ê±°ë˜ ìœ í˜• í•„í„°
    trade_types = ['ì „ì²´'] + sorted(df['ê±°ë˜ìœ í˜•'].unique().tolist())
    selected_trade = st.selectbox('1ï¸âƒ£ ê±°ë˜ ìœ í˜•', trade_types)
    
    # 2. ë™ í•„í„°
    dong_list = ['ì „ì²´'] + sorted(df['ë™'].unique().tolist())
    selected_dong = st.selectbox('2ï¸âƒ£ ë™ ì„ íƒ', dong_list)
    
    # 3. ë©´ì  í•„í„°
    min_area, max_area = get_area_range(df)
    area_range = st.slider(
        '3ï¸âƒ£ ì „ìš©ë©´ì  (ã¡)',
        min_value=float(min_area),
        max_value=float(max_area),
        value=(float(min_area), float(max_area)),
        step=0.1
    )
    area_range
    st.markdown("---")
    
    # í•„í„° ì´ˆê¸°í™” ë²„íŠ¼
    if st.button("ğŸ”„ í•„í„° ì´ˆê¸°í™”", use_container_width=True):
        st.rerun()

# ==================== í•„í„° ì ìš© ====================

filtered_df = apply_filters(df, selected_trade, selected_dong, area_range)

# ==================== í†µê³„ í‘œì‹œ ====================

col1, col2, col3 = st.columns(3)

with col1:
    st.metric("ğŸ“Š ì „ì²´ ë§¤ë¬¼", len(df))

with col2:
    st.metric("ğŸ” í•„í„°ë§ëœ ë§¤ë¬¼", len(filtered_df))


with col3:
    if not filtered_df.empty:
        trade_counts = filtered_df['ê±°ë˜ìœ í˜•'].value_counts()
        if not trade_counts.empty:
            most_common = trade_counts.index[0]
            st.metric("ğŸ·ï¸ ì£¼ìš” ìœ í˜•", most_common)
        else:
            st.metric("ğŸ·ï¸ ì£¼ìš” ìœ í˜•", "-")
    else:
        st.metric("ğŸ·ï¸ ì£¼ìš” ìœ í˜•", "-")

# ==================== ë§¤ë¬¼ ëª©ë¡ ë° ìƒì„¸ ì •ë³´ ====================

st.markdown("---")
st.subheader(f'ğŸ“‹ ë§¤ë¬¼ ëª©ë¡ (ì´ {len(filtered_df)}ê±´)')

if filtered_df.empty:
    st.warning("âš ï¸ ì„ íƒëœ í•„í„° ì¡°ê±´ì— í•´ë‹¹í•˜ëŠ” ë§¤ë¬¼ì´ ì—†ìŠµë‹ˆë‹¤.")
    st.info("ğŸ’¡ í•„í„° ì¡°ê±´ì„ ì¡°ì •í•˜ê±°ë‚˜ 'í•„í„° ì´ˆê¸°í™”' ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.")
else:
    apartment_options = filtered_df['ë§¤ë¬¼ëª…'].tolist()
    
    selected_apt_name = st.selectbox(
        'ë§¤ë¬¼ì„ ì„ íƒí•˜ì„¸ìš”',
        apartment_options,
        index=0,
        label_visibility="collapsed"
    )

    selected_apt_data = filtered_df[filtered_df['ë§¤ë¬¼ëª…'] == selected_apt_name].iloc[0]
    render_property_details(selected_apt_data)

# ==================== í‘¸í„° ====================

st.markdown("---")
st.caption("ğŸ  ë„¤ì´ë²„ ë¶€ë™ì‚° API ê¸°ë°˜ ë§¤ë¬¼ ì •ë³´ ì¡°íšŒ ì‹œìŠ¤í…œ")
